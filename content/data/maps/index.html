<h2>Maps</h2>
<ul>
    <li><a href="#transitivity-ratio">Transitivity-ratio map</a></li>
    <li><a href="#transitivity">Customizable transitivity and locus map</a></li>
    <li><a href="#predicatepairs">Customizable predicate-pair map</a></li>
</ul>
<h3 id="transitivity-ratio">Transitivity-ratio map</h3>
<p>This map shows the ratio of transitive predicates in the languages of the sample.</p>
<p>Colour codes:</p>
<ul>
    <li style="list-style-type: none;"><div class="circle very-high-ratio"></div> – 60–81%.</li>
    <li style="list-style-type: none;"><div class="circle high-ratio"></div> – 53–59%.</li>
    <li style="list-style-type: none;"><div class="circle moderate-ratio"></div> – 47–52%.</li>
    <li style="list-style-type: none;"><div class="circle low-ratio"></div> – 40–46%.</li>
    <li style="list-style-type: none;"><div class="circle very-low-ratio"></div> – 27–39%.</li>
</ul>
<p>Values above 81% and below 27% have not been observed.</p>
<div id="transitivity-ratio-map" style="width: 960px; height: 600px; border: 1px dotted darkgray; margin-bottom: 30px; margin-top: 15px;"></div>

<h3 id="transitivity">Customizable transitivity and locus map</h3>
<p>This map shows whether translation equivalents of a given predicate (‘attack’, ‘be afraid’, etc.) belong to the transitive class in the languages of the sample. Non-transitive equivalents are further divided into three types based on their locus of intransitivity, i.e., whether the first argument (X), the second argument (Y), or both arguments are encoded by oblique devices. See [How to read the data]{{ how to read the data }} for more detail on Locus.</p>
<p>Colour codes:</p>
<ul>
    <li>Red: transitive</li>
    <li>Blue: X-locus (the first argument is encoded by an oblique device)</li>
    <li>Yellow: Y-locus (the second argument is encoded by an oblique device)</li>
    <li>Black: XY-locus (both arguments are encoded by oblique devices)</li>
    <li>Grey: no data</li>
</ul>
<label for="tr-locus-select">Select a predicate:</label>
<select name="tr-locus" id="tr-locus-select" onchange="redrawPredicateMap(this.value);" style="width: 300px;">
    <option value="---" disabled>---</option>
</select>
<input type="button" value="Switch to Russian labels" class="language-switch-button" onclick="populateSelectMenus();">
<div id="transitivity-map" style="width: 960px; height: 600px; border: 1px dotted darkgray; margin-bottom: 30px; margin-top: 15px;"></div>

<h3 id="predicatepairs">Customizable predicate-pair map</h3>
<p>This map shows whether translation equivalents of two selected predicates (e.g., ‘be afraid’ and ‘avoid’) pattern together in terms of their valency class in individual languages. Note that the equivalents are considered belonging to the same valency class if and only if their first and second arguments are aligned (e.g., the classes tagged “DAT_NOM” and “NOM_DAT” in Russian are considered two different classes for the purposes of the project). See [How to read the data]{{ how to read the data }} for more detail on how language-specific valency patterns are identified.</p>
<p>Colour codes:</p>
<ul>
    <li>Red: the two equivalents belong to the same valency class</li>
    <li>Blue: the two equivalents belong to different valency classes</li>
    <li>Grey: no data (for at least one of the predicates)</li>
</ul>
<div style="display: grid; grid-template-columns: 310px 310px;">
    <div style="grid-column: 1/2;">
        <label for="predicate1-select">Select first predicate:</label>
        <select name="predicate1" id="predicate1-select" onchange="redrawPredicatePairMap();" style="width: 300px;">
            <option value="---" disabled>---</option>
        </select>
        <input type="button" value="Switch to Russian labels" class="language-switch-button" onclick="populateSelectMenus();">
    </div>
    <div style="grid-column: 2/3;">
        <label for="predicate2-select">Select second predicate:</label>
        <select name="predicate1" id="predicate2-select" onchange="redrawPredicatePairMap();" style="width: 300px;">
            <option value="---" disabled>---</option>
        </select>
    </div>
</div>
<div id="predicate-pair-map" style="width: 960px; height: 600px; border: 1px dotted darkgray; margin-top: 15px;"></div>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"
   integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js" integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew==" crossorigin=""></script>
<script>
    // Data.
    let external2internal = {},
        predicate2schemaEn = {},
        predicate2schemaRu = {},
        predicateName2No = {},
        predicatesRu = {},
        predicatesEn = {},
        coords = {},
        nameIndexDict = {};
    let map1markers = [], map2markers = [];  // For deleting them.
    let nextSelectLang = 'en';  // For toggling.

    for (let i = 0; i < languageData[0].length; i++) {
        nameIndexDict[languageData[0][i]] = i;
    }
    for (const row of languageData.slice(1)) {
        const externalName = row[nameIndexDict['language_external']];
        external2internal[externalName] = row[nameIndexDict['language']];
        coords[externalName] = {
            lat: row[nameIndexDict['latitude']],
            lon: row[nameIndexDict['longitude']]
        };
    }
    for (const row of predicateData.slice(1)) {
        predicatesEn      [row[0]] = row[1];
        predicatesRu      [row[0]] = row[4];
        predicate2schemaEn[row[0]] = row[2];
        predicate2schemaRu[row[0]] = row[5];
        predicateName2No  [row[1]] = row[0];
    }
    // Extract active languages for links
    let activeLanguages = new Set();
    for (const row of fullData.slice(1)) {
        activeLanguages.add(row[0]);
    }

    // Collect loci from full table and structural table
    let predicateLanguageLocusDict = {};
    for (const row of fullData.slice(1)) {
        const languageExternal = row[0],
            predicate          = row[1],
            predicateNo        = predicateName2No[predicate],
            locus              = row[6];
        if (!predicateLanguageLocusDict.hasOwnProperty(predicateNo))
            predicateLanguageLocusDict[predicateNo] = {};
        predicateLanguageLocusDict[predicateNo][languageExternal] = locus;
    }
    for (const row of structuralData.slice(1)) {
        const languageExternal = row[0],
            predicate          = row[1],
            predicateNo        = predicateName2No[predicate],
            locus              = row[5];
        if (!predicateLanguageLocusDict.hasOwnProperty(predicateNo))
            predicateLanguageLocusDict[predicateNo] = {};
        predicateLanguageLocusDict[predicateNo][languageExternal] = locus;
    }

    // The workhorse functions
    let map1, map2, map3;
    const colourMap = {
        'TR': 'red',
        'X': 'blue',
        'Y': 'yellow',
        'XY': 'black'
    };
    function get(dict, key, plug) {
        if (dict.hasOwnProperty(key))
            return dict[key];
        else
            return plug;
    }
    function redrawPredicateMap(predicateNo) {
        for (const marker of map1markers)
            map1.removeLayer(marker);
        map1markers.length = 0;

        for (const lang in coords) {
            if (!coords.hasOwnProperty(lang))
                continue;
            const id = external2internal[lang],
                lat = coords[lang].lat,
                lon = coords[lang].lon;

            let circle = L.divIcon({
                className: `circle circle-${get(colourMap, predicateLanguageLocusDict[predicateNo][lang], 'grey')}`,
                iconSize: [10, 10]
            });
            let marker = L.marker([lat, lon], {
                icon: circle,
                title: lang
            });
            if (activeLanguages.has(lang))
                marker.on('click', () => {
                    window.open(`${siteURL}/languages/descriptions/${id}.html`)
                });
            map1markers.push(marker);
            marker.addTo(map1);
        }
    }

    function redrawPredicatePairMap() {
        let pred1 = document.getElementById('predicate1-select').value,
            pred2 = document.getElementById('predicate2-select').value;
        if (pred1 === '---' || pred2 === '---')
            return;

        pred1 = parseInt(pred1);
        pred2 = parseInt(pred2);

        for (const marker of map2markers)
            map2.removeLayer(marker);
        map2markers.length = 0;

        // Select rows
        let pred1row, pred2row;
        for (const row of patternsData) {
            if (row[0] === pred1) {
                pred1row = row;
            }
            if (row[0] === pred2) {
                pred2row = row;
            }
        }
        console.assert(pred1row !== undefined && pred2row !== undefined);

        for (const lang in coords) {
            if (!coords.hasOwnProperty(lang))
                continue;
            const langIdx = patternsData[0].indexOf(external2internal[lang]),
                pred1Pattern = pred1row[langIdx],
                pred2Pattern = pred2row[langIdx];
            let colour;
            if (pred1Pattern === '' || pred2Pattern === '')
                colour = 'grey';
            else if (pred1Pattern === pred2Pattern)
                colour = 'red';
            else
                colour = 'blue';
            let circle = L.divIcon({
                className: `circle circle-${colour}`,
                iconSize: [10, 10]
            });
            let marker = L.marker([coords[lang].lat, coords[lang].lon], {
                icon: circle,
                title: lang
            });
            if (activeLanguages.has(lang))
                marker.on('click', () => {
                    window.open(`${siteURL}/languages/descriptions/${external2internal[lang]}.html`)
                });
            map2markers.push(marker);
            marker.addTo(map2);
        }
    }

    function getPredicateOption(predicateNo, language) {
        let option = document.createElement('option');
        option.value = predicateNo;
        if (language === 'ru') {
            option.innerHTML = predicatesRu[predicateNo]
                .replace(/_/g, ' ')
                .replace(/#(.*)#/g, ' ($1)') + ` [<em>${predicate2schemaRu[predicateNo]}</em>]`;
        } else {
            option.innerHTML = predicatesEn[predicateNo]
                .replace(/_/g, ' ')
                .replace(/#(.*)#/g, ' ($1)') + ` [<em>${predicate2schemaEn[predicateNo]}</em>]`;
        }
        return option;
    }

    function removeNonFirstChildren(element) {
        let children = element.children;
        for (let i = children.length-1; i > 0; i--)
            element.removeChild(children[i]);
    }

    function populateSelectMenus(resetMenus=false) {
        const language = nextSelectLang;
        nextSelectLang = nextSelectLang === 'en' ? 'ru' : 'en';
        // Retrieve current values
        let curval1, curval2, curval3;
        if (!resetMenus) {
            curval1 = document.getElementById('tr-locus-select').value;
            curval2 = document.getElementById('predicate1-select').value;
            curval3 = document.getElementById('predicate2-select').value;
        }
        // Populate select menus
        let sortedPredicates = [];
        for (const key in predicateLanguageLocusDict)
            if (predicateLanguageLocusDict.hasOwnProperty(key))
                sortedPredicates.push(key);
        sortedPredicates.sort((pred1, pred2) => {
            let key1, key2;
            if (language === 'ru') {
                key1 = predicatesRu[pred1];
                key2 = predicatesRu[pred2];
            } else {
                key1 = predicatesEn[pred1];
                key2 = predicatesEn[pred2];
            }
            if (key1 < key2)
                return -1;
            else if (key1 > key2)
                return 1;
            else
                return 0;
        });
        removeNonFirstChildren(document.getElementById('tr-locus-select'));
        removeNonFirstChildren(document.getElementById('predicate1-select'));
        removeNonFirstChildren(document.getElementById('predicate2-select'));
        for (const key of sortedPredicates) {
            document.getElementById('tr-locus-select').appendChild(getPredicateOption(key, language));
            document.getElementById('predicate1-select').appendChild(getPredicateOption(key, language));
            document.getElementById('predicate2-select').appendChild(getPredicateOption(key, language));
        }
        if (resetMenus) {
            document.getElementById('tr-locus-select').value   = '---';
            document.getElementById('predicate1-select').value = '---';
            document.getElementById('predicate2-select').value = '---';
        } else {
            document.getElementById('tr-locus-select').value   = curval1;
            document.getElementById('predicate1-select').value = curval2;
            document.getElementById('predicate2-select').value = curval3;
        }

        // Rename the button
        let buttons = document.getElementsByClassName('language-switch-button');
        for (let i = 0; i < buttons.length; i++) {
            if (language === 'ru')
                buttons[i].value = buttons[i].value.replace('Russian', 'English');
            else
                buttons[i].value = buttons[i].value.replace('English', 'Russian');
        }
    }


    function drawMap(canvasId) {
        let map = L.map(canvasId, {zoomControl: false});
        map.setView([52.483333, 96.085833], 2);
        L.control.zoom({position: 'bottomleft'}).addTo(map);
        L.tileLayer(
            'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
            {
                attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>',
                maxZoom: 18,
            })
            .addTo(map);
        return map;
    }

    function getTRRatioColour(ratio) {
        if (ratio < 0.4) {
            return 'very-low-ratio';
        } else if (ratio < 0.47) {
            return 'low-ratio';
        } else if (ratio < 0.53) {
            return 'moderate-ratio';
        } else if (ratio < 0.6) {
            return 'high-ratio';
        } else {
            return 'very-high-ratio';
        }
    }

    /** 
     * Adds colour-coded transitivity ratio markers to the map
     * passed as argument. Uses the data from the Patterns table.
     * @function drawTransitivityRatioMap
     * @param {DIV} map the DOM div node with a Leaflet map.
    */
    function drawTransitivityRatioMap(map) {
        const lo = patternsData[0].indexOf('Abaza'),
              hi = patternsData[0].length,
              langIdx    = languageData[0].indexOf('language'),
              langExtIdx = languageData[0].indexOf('language_external'),
              latIdx     = languageData[0].indexOf('latitude'),
              lonIdx     = languageData[0].indexOf('longitude');

        for (let i = lo; i < hi; i++) {
            const lang = patternsData[0][i],
                patterns = patternsData.slice(1)
                    .map(row => row[i]);

            // Compute the ratio
            let TR       = 0, 
                total    = 0, 
                TR_ratio = 0;
            for (const pattern of patterns) {
                if (pattern === "")
                    continue;
                total++;
                if (pattern == "TR")
                    TR++;
            }
            TR_ratio = TR / total;
            
            // Add a marker
            for (const row of languageData.slice(0)) {
                if (row[langIdx] == lang) {
                    const lat          = row[latIdx],
                          lon          = row[lonIdx],
                          langExternal = row[langExtIdx];
                    let circle = L.divIcon({
                        className: `circle ${getTRRatioColour(TR_ratio)}`,
                        iconSize: [10, 10]
                    });
                    let marker = L.marker([lat, lon], {
                        icon: circle,
                        title: langExternal
                    });
                    marker.addTo(map);
                    break;
                }
            }
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        populateSelectMenus(true);

        map1 = drawMap('transitivity-map');
        map2 = drawMap('predicate-pair-map');
        map3 = drawMap('transitivity-ratio-map');
        drawTransitivityRatioMap(map3);
    });
</script>