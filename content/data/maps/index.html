<h2>Maps</h2>
<ul>
    <li><a href="#transitivity-ratio">Transitivity and locus ratio maps</a>
        <ul>
            <li><a href="#tr-ratios">Ratios of transitive predicates</a></li>
            <li><a href="#x-ratios">Ratios of predicates with the first argument (X) encoded by oblique devices</a></li>
            <li><a href="#y-ratios">Ratios of predicates with the second argument (Y) encoded by oblique devices</a></li>
            <li><a href="#xy-ratios">Ratios of predicates with both arguments (XY) encoded by oblique devices</a></li>
        </ul>
    </li>
    <li><a href="#transitivity">Customizable transitivity and locus map</a></li>
    <li><a href="#predicatepairs">Customizable predicate-pair map</a></li>
</ul>
<h3 id="transitivity-ratio">Transitivity and locus ratio maps</h3>
<p>These four maps display the ratios of transitive predicates and of three types of intransitive patterns in the languages of the sample. 
    The three types of intransitive patterns are distinguished based on whether the first argument (X), the second argument (Y), or both arguments (X and Y) 
    are encoded by oblique devices; see the section on locus in [How to read the data]{{ how to read the data }} for more detail.</p>
<h4 id="tr-ratios">Ratios of transitive predicates</h4>
<p>Colour codes:</p>
<ul>
    <li style="list-style-type: none;"><div class="circle very-high-ratio"></div> – 60–81%</li>
    <li style="list-style-type: none;"><div class="circle high-ratio"></div> – 53–59%</li>
    <li style="list-style-type: none;"><div class="circle moderate-ratio"></div> – 47–52%</li>
    <li style="list-style-type: none;"><div class="circle low-ratio"></div> – 40–46%</li>
    <li style="list-style-type: none;"><div class="circle very-low-ratio"></div> – 27–39%</li>
</ul>
<p>Values above 81% and below 27% have not been observed.</p>
<div id="transitivity-ratio-map" style="width: 960px; height: 600px; border: 1px dotted darkgray; margin-bottom: 30px; margin-top: 15px;"></div>

<h4 id="x-ratios">Ratios of predicates with the first argument (X) encoded by oblique devices</h4>
<p>Colour codes:</p>
<ul>
    <li style="list-style-type: none;"><div class="circle very-high-ratio"></div> – 13–23%</li>
    <li style="list-style-type: none;"><div class="circle high-ratio"></div> – 7–12%</li>
    <li style="list-style-type: none;"><div class="circle moderate-ratio"></div> – 5–6%</li>
    <li style="list-style-type: none;"><div class="circle low-ratio"></div> – 3–4%</li>
    <li style="list-style-type: none;"><div class="circle very-low-ratio"></div> – below 3%</li>
</ul>
<p>Values above 23% have not been observed.</p>
<div id="X-ratio-map" style="width: 960px; height: 600px; border: 1px dotted darkgray; margin-bottom: 30px; margin-top: 15px;"></div>

<h4 id="y-ratios">Ratios of predicates with the second argument (Y) encoded by oblique devices</h4>
<p>Colour codes:</p>
<ul>
    <li style="list-style-type: none;"><div class="circle very-high-ratio"></div> – 50–65%</li>
    <li style="list-style-type: none;"><div class="circle high-ratio"></div> – 45–49%</li>
    <li style="list-style-type: none;"><div class="circle moderate-ratio"></div> – 38–44%</li>
    <li style="list-style-type: none;"><div class="circle low-ratio"></div> – 30–37%</li>
    <li style="list-style-type: none;"><div class="circle very-low-ratio"></div> – 16–29%</li>
</ul>
<p>Values above 65% and below 16% have not been observed.</p>
<div id="Y-ratio-map" style="width: 960px; height: 600px; border: 1px dotted darkgray; margin-bottom: 30px; margin-top: 15px;"></div>

<h4 id="xy-ratios">Ratios of predicates with both arguments (XY) encoded by oblique devices</h4>
<p>Colour codes:</p>
<ul>
    <li style="list-style-type: none;"><div class="circle very-high-ratio"></div> – 8–12%</li>
    <li style="list-style-type: none;"><div class="circle high-ratio"></div> – 5–7%</li>
    <li style="list-style-type: none;"><div class="circle moderate-ratio"></div> – 3–4%</li>
    <li style="list-style-type: none;"><div class="circle low-ratio"></div> – 1–2%</li>
    <li style="list-style-type: none;"><div class="circle very-low-ratio"></div> – 0 occurrences</li>
</ul>
<div id="XY-ratio-map" style="width: 960px; height: 600px; border: 1px dotted darkgray; margin-bottom: 30px; margin-top: 15px;"></div>

<h3 id="transitivity">Customizable transitivity and locus map</h3>
<p>This map shows whether translation equivalents of a given predicate (‘attack’, ‘be afraid’, etc.) belong to the transitive class in the languages of the sample. 
    Non-transitive equivalents are further divided into three types based on their locus of intransitivity, i.e., whether the first argument (X), the second argument (Y), 
    or both arguments are encoded by oblique devices. See [How to read the data]{{ how to read the data }} for more detail on locus.</p>
<p>Colour codes:</p>
<ul>
    <li style="list-style-type: none;"><div class="circle circle-red"></div> – transitive</li>
    <li style="list-style-type: none;"><div class="circle circle-blue"></div> – X-locus (the first argument is encoded by an oblique device)</li>
    <li style="list-style-type: none;"><div class="circle circle-yellow"></div> – Y-locus (the second argument is encoded by an oblique device)</li>
    <li style="list-style-type: none;"><div class="circle circle-black"></div> – XY-locus (both arguments are encoded by oblique devices)</li>
    <li style="list-style-type: none;"><div class="circle circle-grey"></div> – no data</li>
</ul>
<!-- <ul>
    <li>Red: transitive</li>
    <li>Blue: X-locus (the first argument is encoded by an oblique device)</li>
    <li>Yellow: Y-locus (the second argument is encoded by an oblique device)</li>
    <li>Black: XY-locus (both arguments are encoded by oblique devices)</li>
    <li>Grey: no data</li>
</ul> -->
<label for="tr-locus-select">Select a predicate:</label>
<select name="tr-locus" id="tr-locus-select" onchange="redrawPredicateMap(this.value);" style="width: 300px;">
    <option value="---" disabled>---</option>
</select>
<input type="button" value="Switch to Russian labels" class="language-switch-button" onclick="populateSelectMenus();">
<div id="transitivity-map" style="width: 960px; height: 600px; border: 1px dotted darkgray; margin-bottom: 30px; margin-top: 15px;"></div>

<h3 id="predicatepairs">Customizable predicate-pair map</h3>
<p>This map shows whether translation equivalents of two selected predicates (e.g., ‘be afraid’ and ‘avoid’) pattern together in terms of their valency class 
    in individual languages. Note that the equivalents are considered belonging to the same valency class if and only if their first and second arguments are 
    aligned (e.g., the classes tagged “DAT_NOM” and “NOM_DAT” in Russian are considered two different classes for the purposes of the project). 
    See [How to read the data]{{ how to read the data }} for more detail on how language-specific valency patterns are identified.</p>
<p>Colour codes:</p>
<ul>
    <li style="list-style-type: none;"><div class="circle circle-red"></div> – the two equivalents belong to the same valency class</li>
    <li style="list-style-type: none;"><div class="circle circle-blue"></div> – the two equivalents belong to different valency classes</li>
    <li style="list-style-type: none;"><div class="circle circle-grey"></div> – no data (for at least one of the predicates)</li>
</ul>
<!-- <ul>
    <li>Red: the two equivalents belong to the same valency class</li>
    <li>Blue: the two equivalents belong to different valency classes</li>
    <li>Grey: no data (for at least one of the predicates)</li>
</ul> -->
<div style="display: grid; grid-template-columns: 310px 310px;">
    <div style="grid-column: 1/2;">
        <label for="predicate1-select">Select first predicate:</label>
        <select name="predicate1" id="predicate1-select" onchange="redrawPredicatePairMap();" style="width: 300px;">
            <option value="---" disabled>---</option>
        </select>
        <input type="button" value="Switch to Russian labels" class="language-switch-button" onclick="populateSelectMenus();">
    </div>
    <div style="grid-column: 2/3;">
        <label for="predicate2-select">Select second predicate:</label>
        <select name="predicate1" id="predicate2-select" onchange="redrawPredicatePairMap();" style="width: 300px;">
            <option value="---" disabled>---</option>
        </select>
    </div>
</div>
<div id="predicate-pair-map" style="width: 960px; height: 600px; border: 1px dotted darkgray; margin-top: 15px;"></div>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"
   integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js" integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew==" crossorigin=""></script>
<script>
    // Data.
    let external2internal = {},
        predicate2schemaEn = {},
        predicate2schemaRu = {},
        predicateName2No = {},
        predicatesRu = {},
        predicatesEn = {},
        coords = {},
        nameIndexDict = {};
    let map1markers = [], map2markers = [];  // For deleting them.
    let nextSelectLang = 'en';  // For toggling.

    for (let i = 0; i < languageData[0].length; i++) {
        nameIndexDict[languageData[0][i]] = i;
    }
    for (const row of languageData.slice(1)) {
        const externalName = row[nameIndexDict['language_external']];
        external2internal[externalName] = row[nameIndexDict['language']];
        coords[externalName] = {
            lat: row[nameIndexDict['latitude']],
            lon: row[nameIndexDict['longitude']]
        };
    }
    for (const row of predicateData.slice(1)) {
        predicatesEn      [row[0]] = row[1];
        predicatesRu      [row[0]] = row[4];
        predicate2schemaEn[row[0]] = row[2];
        predicate2schemaRu[row[0]] = row[5];
        predicateName2No  [row[1]] = row[0];
    }
    // Extract active languages for links
    let activeLanguages = new Set();
    for (const row of fullData.slice(1)) {
        activeLanguages.add(row[0]);
    }

    // Collect loci from full table and structural table
    let predicateLanguageLocusDict = {};
    for (const row of fullData.slice(1)) {
        const languageExternal = row[0],
            predicate          = row[1],
            predicateNo        = predicateName2No[predicate],
            locus              = row[6];
        if (!predicateLanguageLocusDict.hasOwnProperty(predicateNo))
            predicateLanguageLocusDict[predicateNo] = {};
        predicateLanguageLocusDict[predicateNo][languageExternal] = locus;
    }
    for (const row of structuralData.slice(1)) {
        const languageExternal = row[0],
            predicate          = row[1],
            predicateNo        = predicateName2No[predicate],
            locus              = row[5];
        if (!predicateLanguageLocusDict.hasOwnProperty(predicateNo))
            predicateLanguageLocusDict[predicateNo] = {};
        predicateLanguageLocusDict[predicateNo][languageExternal] = locus;
    }

    // The workhorse functions
    let map1, map2, map3;
    const colourMap = {
        'TR': 'red',
        'X': 'blue',
        'Y': 'yellow',
        'XY': 'black'
    };
    function get(dict, key, plug) {
        if (dict.hasOwnProperty(key))
            return dict[key];
        else
            return plug;
    }
    function redrawPredicateMap(predicateNo) {
        for (const marker of map1markers)
            map1.removeLayer(marker);
        map1markers.length = 0;

        for (const lang in coords) {
            if (!coords.hasOwnProperty(lang))
                continue;
            const id = external2internal[lang],
                lat = coords[lang].lat,
                lon = coords[lang].lon;

            let circle = L.divIcon({
                className: `circle circle-${get(colourMap, predicateLanguageLocusDict[predicateNo][lang], 'grey')}`,
                iconSize: [10, 10]
            });
            let marker = L.marker([lat, lon], {
                icon: circle,
                title: lang
            });
            if (activeLanguages.has(lang))
                marker.on('click', () => {
                    window.open(`${siteURL}/languages/descriptions/${id}.html`)
                });
            map1markers.push(marker);
            marker.addTo(map1);
        }
    }

    function redrawPredicatePairMap() {
        let pred1 = document.getElementById('predicate1-select').value,
            pred2 = document.getElementById('predicate2-select').value;
        if (pred1 === '---' || pred2 === '---')
            return;

        pred1 = parseInt(pred1);
        pred2 = parseInt(pred2);

        for (const marker of map2markers)
            map2.removeLayer(marker);
        map2markers.length = 0;

        // Select rows
        let pred1row, pred2row;
        for (const row of patternsData) {
            if (row[0] === pred1) {
                pred1row = row;
            }
            if (row[0] === pred2) {
                pred2row = row;
            }
        }
        console.assert(pred1row !== undefined && pred2row !== undefined);

        for (const lang in coords) {
            if (!coords.hasOwnProperty(lang))
                continue;
            const langIdx = patternsData[0].indexOf(external2internal[lang]),
                pred1Pattern = pred1row[langIdx],
                pred2Pattern = pred2row[langIdx];
            let colour;
            if (pred1Pattern === '' || pred2Pattern === '')
                colour = 'grey';
            else if (pred1Pattern === pred2Pattern)
                colour = 'red';
            else
                colour = 'blue';
            let circle = L.divIcon({
                className: `circle circle-${colour}`,
                iconSize: [10, 10]
            });
            let marker = L.marker([coords[lang].lat, coords[lang].lon], {
                icon: circle,
                title: lang
            });
            if (activeLanguages.has(lang))
                marker.on('click', () => {
                    window.open(`${siteURL}/languages/descriptions/${external2internal[lang]}.html`)
                });
            map2markers.push(marker);
            marker.addTo(map2);
        }
    }

    function getPredicateOption(predicateNo, language) {
        let option = document.createElement('option');
        option.value = predicateNo;
        if (language === 'ru') {
            option.innerHTML = predicatesRu[predicateNo]
                .replace(/_/g, ' ')
                .replace(/#(.*)#/g, ' ($1)') + ` [<em>${predicate2schemaRu[predicateNo]}</em>]`;
        } else {
            option.innerHTML = predicatesEn[predicateNo]
                .replace(/_/g, ' ')
                .replace(/#(.*)#/g, ' ($1)') + ` [<em>${predicate2schemaEn[predicateNo]}</em>]`;
        }
        return option;
    }

    function removeNonFirstChildren(element) {
        let children = element.children;
        for (let i = children.length-1; i > 0; i--)
            element.removeChild(children[i]);
    }

    function populateSelectMenus(resetMenus=false) {
        const language = nextSelectLang;
        nextSelectLang = nextSelectLang === 'en' ? 'ru' : 'en';
        // Retrieve current values
        let curval1, curval2, curval3;
        if (!resetMenus) {
            curval1 = document.getElementById('tr-locus-select').value;
            curval2 = document.getElementById('predicate1-select').value;
            curval3 = document.getElementById('predicate2-select').value;
        }
        // Populate select menus
        let sortedPredicates = [];
        for (const key in predicateLanguageLocusDict)
            if (predicateLanguageLocusDict.hasOwnProperty(key))
                sortedPredicates.push(key);
        sortedPredicates.sort((pred1, pred2) => {
            let key1, key2;
            if (language === 'ru') {
                key1 = predicatesRu[pred1];
                key2 = predicatesRu[pred2];
            } else {
                key1 = predicatesEn[pred1];
                key2 = predicatesEn[pred2];
            }
            if (key1 < key2)
                return -1;
            else if (key1 > key2)
                return 1;
            else
                return 0;
        });
        removeNonFirstChildren(document.getElementById('tr-locus-select'));
        removeNonFirstChildren(document.getElementById('predicate1-select'));
        removeNonFirstChildren(document.getElementById('predicate2-select'));
        for (const key of sortedPredicates) {
            document.getElementById('tr-locus-select').appendChild(getPredicateOption(key, language));
            document.getElementById('predicate1-select').appendChild(getPredicateOption(key, language));
            document.getElementById('predicate2-select').appendChild(getPredicateOption(key, language));
        }
        if (resetMenus) {
            document.getElementById('tr-locus-select').value   = '---';
            document.getElementById('predicate1-select').value = '---';
            document.getElementById('predicate2-select').value = '---';
        } else {
            document.getElementById('tr-locus-select').value   = curval1;
            document.getElementById('predicate1-select').value = curval2;
            document.getElementById('predicate2-select').value = curval3;
        }

        // Rename the button
        let buttons = document.getElementsByClassName('language-switch-button');
        for (let i = 0; i < buttons.length; i++) {
            if (language === 'ru')
                buttons[i].value = buttons[i].value.replace('Russian', 'English');
            else
                buttons[i].value = buttons[i].value.replace('English', 'Russian');
        }
    }


    function drawMap(canvasId) {
        let map = L.map(canvasId, {zoomControl: false});
        map.setView([52.483333, 96.085833], 2);
        L.control.zoom({position: 'bottomleft'}).addTo(map);
        L.tileLayer(
            'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
            {
                attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>',
                maxZoom: 18,
            })
            .addTo(map);
        return map;
    }

    /**
     * Returns a colour-encoding class name for a given ratio
     * based on a series of cut-off points.
     */
     function getRatioColour(ratio, ratios) {
        if (ratios.length !== 4) {
            alert('Wrong number of cut-off points passed to getRatioColours: ' + ratios.length);
            return;
        }
        ratios.sort();
        const classNames = ['very-low-ratio', 'low-ratio', 'moderate-ratio', 'high-ratio', 'very-high-ratio'];
        for (let i = 0; i < ratios.length; i++)
            if (ratio < ratios[i])
                return classNames[i];
        return classNames[classNames.length-1];
    }

    let getTRRatioColour = ratio => getRatioColour(ratio, [0.4, 0.47, 0.53, 0.6]);
    let getXRatioColour  = ratio => getRatioColour(ratio, [0.03, 0.05, 0.07, 0.13]);
    let getYRatioColour  = ratio => getRatioColour(ratio, [0.3, 0.38, 0.45, 0.5]);
    let getXYRatioColour = ratio => getRatioColour(ratio, [0.01, 0.03, 0.05, 0.08]);

    /** 
     * Adds colour-coded ratio markers to the map.
     * Uses the data from the Patterns table.
     * @function drawTransitivityRatioMap
     * @param {DIV} map the DOM div node with a Leaflet map.
     * @param {string} the pattern to draw the map for.
     * @param {float -> string} the function to select class names for
     *                          markers based on the ratio.
    */
    function drawRatioMap(map, inputPattern, colouringFunction) {
        const lo = patternsData[0].indexOf('Abaza'),
              hi = patternsData[0].length,
              langIdx     = languageData[0].indexOf('language'),
              langExtIdx  = languageData[0].indexOf('language_external'),
              latIdx      = languageData[0].indexOf('latitude'),
              lonIdx      = languageData[0].indexOf('longitude'),
              XLocusIdx   = languageData[0].indexOf('X'),
              YLocusIdx   = languageData[0].indexOf('Y'),
              XYLocusIdx  = languageData[0].indexOf('XY'),
              overallNIdx = languageData[0].indexOf('overallN');

        for (let i = lo; i < hi; i++) {
            const lang = patternsData[0][i],
                patterns = patternsData.slice(1)
                    .map(row => row[i]);

            // Compute the ratio
            // Use different datasets depending on the pattern.
            let TR_ratio;
            if (inputPattern === 'TR') {
                let TR       = 0, 
                    total    = 0;
                for (const pattern of patterns) {
                    if (pattern === "")
                        continue;
                    total++;
                    if (pattern === inputPattern)
                        TR++;
                }
                TR_ratio = TR / total;
            } else {
                // Use the data from Languages
                for (const row of languageData.slice(0)) {
                    if (row[langIdx] === lang) {
                        overallN = row[overallNIdx];
                        let otherValue;
                        switch (inputPattern) {
                            case 'X':
                                otherValue = row[XLocusIdx];
                                break;
                            case 'Y':
                                otherValue = row[YLocusIdx];
                                break;
                            case 'XY':
                                otherValue = row[XYLocusIdx];
                                break;
                            default:
                                alert('Wrong encoding locus passed to drawRatioMap: ' + inputPattern);
                                otherValue = 0;
                                break;
                        }
                        TR_ratio = otherValue / overallN;
                        // console.log(inputPattern, TR_ratio)
                        break;
                    }
                }
            }
            
            // Add a marker
            for (const row of languageData.slice(0)) {
                if (row[langIdx] === lang) {
                    const lat          = row[latIdx],
                          lon          = row[lonIdx],
                          langExternal = row[langExtIdx];
                    let circle = L.divIcon({
                        className: `circle ${colouringFunction(TR_ratio)}`,
                        iconSize: [10, 10]
                    });
                    let marker = L.marker([lat, lon], {
                        icon: circle,
                        title: langExternal
                    });
                    marker.addTo(map);
                    break;
                }
            }
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        populateSelectMenus(true);

        map1 = drawMap('transitivity-map');
        map2 = drawMap('predicate-pair-map');
        map3 = drawMap('transitivity-ratio-map');
        drawRatioMap(map3, 'TR', getTRRatioColour);
        map4 = drawMap('X-ratio-map');
        drawRatioMap(map4, 'X', getXRatioColour);
        map5 = drawMap('Y-ratio-map');
        drawRatioMap(map5, 'Y', getYRatioColour);
        map6 = drawMap('XY-ratio-map');
        drawRatioMap(map6, 'XY', getXYRatioColour);
    });
</script>
