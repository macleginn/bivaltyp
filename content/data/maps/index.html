<h2>Customisable maps</h2>
<ul>
    <li><a href="#transitivity">Transitivity and locus map</a></li>
    <li><a href="#predicatepairs">Predicate-pair map</a></li>
</ul>
<h3 id="transitivity">Transitivity and locus map</h3>
<p>This map shows whether translation equivalents of a given predicate (‘attack’, ‘be afraid’, etc.) belong to the transitive class in the languages of the sample. Non-transitive equivalents are further divided into three types based on their locus of intransitivity, i.e., whether the first argument (X), the second argument (Y), or both arguments are encoded by oblique devices. See [How to read the data]{{ how to read the data }} for more detail on Locus.</p>
<p>Colour codes:</p>
<ul>
    <li>Red: transitive</li>
    <li>Blue: X-locus (the first argument is encoded by an oblique device)</li>
    <li>Yellow: Y-locus (the second argument is encoded by an oblique device)</li>
    <li>Black: XY-locus (both arguments are encoded by oblique devices)</li>
    <li>Grey: no data</li>
</ul>
<label for="tr-locus-select">Select a predicate:</label>
<select name="tr-locus" id="tr-locus-select" onchange="redrawPredicateMap(this.value);" style="width: 300px;">
    <option value="---" disabled>---</option>
</select>
<input type="button" value="Switch to Russian labels" class="language-switch-button" onclick="populateSelectMenus();">
<div id="transitivity-map" style="width: 960px; height: 600px; border: 1px dotted darkgray; margin-bottom: 30px; margin-top: 15px;"></div>

<h3 id="predicatepairs">Predicate-pair map</h3>
<p>This map shows whether translation equivalents of two selected predicates (e.g., ‘be afraid’ and ‘avoid’) pattern together in terms of their valency class in individual languages. Note that the equivalents are considered belonging to the same valency class if and only if their first and second arguments are aligned (e.g., the classes tagged “DAT_NOM” and “NOM_DAT” in Russian are considered two different classes for the purposes of the project). See [How to read the data]{{ how to read the data }} for more detail on how language-specific valency patterns are identified.</p>
<p>Colour codes:</p>
<ul>
    <li>Red: the two equivalents belong to the same valency class</li>
    <li>Blue: the two equivalents belong to different valency classes</li>
    <li>Grey: no data (for at least one of the predicates)</li>
</ul>
<div style="display: grid; grid-template-columns: 310px 310px;">
    <div style="grid-column: 1/2;">
        <label for="predicate1-select">Select first predicate:</label>
        <select name="predicate1" id="predicate1-select" onchange="redrawPredicatePairMap();" style="width: 300px;">
            <option value="---" disabled>---</option>
        </select>
        <input type="button" value="Switch to Russian labels" class="language-switch-button" onclick="populateSelectMenus();">
    </div>
    <div style="grid-column: 2/3;">
        <label for="predicate2-select">Select second predicate:</label>
        <select name="predicate1" id="predicate2-select" onchange="redrawPredicatePairMap();" style="width: 300px;">
            <option value="---" disabled>---</option>
        </select>
    </div>
</div>
<div id="predicate-pair-map" style="width: 960px; height: 600px; border: 1px dotted darkgray; margin-top: 15px;"></div>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"
   integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js" integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew==" crossorigin=""></script>
<script>
    // Data.
    let external2internal = {},
        predicate2schema = {},
        predicateEn2Ru = {},
        predicate2schemaRu = {},
        coords = {},
        nameIndexDict = {};
    let map1markers = [], map2markers = [];  // For deleting them.

    // For toggling
    let nextSelectLang = 'en';

    for (let i = 0; i < languageData[0].length; i++) {
        nameIndexDict[languageData[0][i]] = i;
    }
    for (const row of languageData.slice(1)) {
        const externalName = row[nameIndexDict['language_external']];
        external2internal[externalName] = row[nameIndexDict['language']];
        coords[externalName] = {
            lat: row[nameIndexDict['latitude']],
            lon: row[nameIndexDict['longitude']]
        };
    }
    for (const row of predicateData.slice(1)) {
        predicate2schema[row[1]] = row[2];
        predicateEn2Ru[row[1]] = row[4];
        predicate2schemaRu[row[4]] = row[5];
    }
    // Extract active languages for links
    let activeLanguages = new Set();
    for (const row of fullData.slice(1)) {
        activeLanguages.add(row[0]);
    }

    // Collect loci from full table and structural table
    let predicateLanguageLocusDict = {};
    for (const row of fullData.slice(1)) {
        const languageExternal = row[0],
            predicate          = row[1],
            locus              = row[6];
        if (!predicateLanguageLocusDict.hasOwnProperty(predicate))
            predicateLanguageLocusDict[predicate] = {};
        predicateLanguageLocusDict[predicate][languageExternal] = locus;
    }
    for (const row of structuralData.slice(1)) {
        const languageExternal = row[0],
            predicate          = row[1],
            locus              = row[5];
        if (!predicateLanguageLocusDict.hasOwnProperty(predicate))
            predicateLanguageLocusDict[predicate] = {};
        predicateLanguageLocusDict[predicate][languageExternal] = locus;
    }

    // The workhorse functions
    let map1, map2;
    const colourMap = {
        'TR': 'red',
        'X': 'blue',
        'Y': 'yellow',
        'XY': 'black'
    };
    function get(dict, key, plug) {
        if (dict.hasOwnProperty(key))
            return dict[key];
        else
            return plug;
    }
    function redrawPredicateMap(predicate) {
        for (const marker of map1markers)
            map1.removeLayer(marker);
        map1markers.length = 0;

        for (const lang in coords) {
            if (!coords.hasOwnProperty(lang))
                continue;
            const id = external2internal[lang],
                lat = coords[lang].lat,
                lon = coords[lang].lon;

            let circle = L.divIcon({
                className: `circle circle-${get(colourMap, predicateLanguageLocusDict[predicate][lang], 'grey')}`,
                iconSize: [10, 10]
            });
            let marker = L.marker([lat, lon], {
                icon: circle,
                title: lang
            });
            if (activeLanguages.has(lang))
                marker.on('click', () => {
                    window.open(`${siteURL}/languages/descriptions/${id}.html`)
                });
            map1markers.push(marker);
            marker.addTo(map1);
        }
    }

    function redrawPredicatePairMap() {
        const pred1 = document.getElementById('predicate1-select').value,
            pred2 = document.getElementById('predicate2-select').value;
        if (pred1 === '---' || pred2 === '---')
            return;

        for (const marker of map2markers)
            map2.removeLayer(marker);
        map2markers.length = 0;

        // Select rows
        let pred1row, pred2row;
        for (const row of patternsData) {
            if (row[1] === pred1) {
                pred1row = row;
            }
            if (row[1] === pred2) {
                pred2row = row;
            }
        }
        console.assert(pred1row !== undefined && pred2row !== undefined);

        for (const lang in coords) {
            if (!coords.hasOwnProperty(lang))
                continue;
            const langIdx = patternsData[0].indexOf(external2internal[lang]),
                pred1Pattern = pred1row[langIdx],
                pred2Pattern = pred2row[langIdx];
            let colour;
            if (pred1Pattern === '' || pred2Pattern === '')
                colour = 'grey';
            else if (pred1Pattern === pred2Pattern)
                colour = 'red';
            else
                colour = 'blue';
            let circle = L.divIcon({
                className: `circle circle-${colour}`,
                iconSize: [10, 10]
            });
            let marker = L.marker([coords[lang].lat, coords[lang].lon], {
                icon: circle,
                title: lang
            });
            if (activeLanguages.has(lang))
                marker.on('click', () => {
                    window.open(`${siteURL}/languages/descriptions/${external2internal[lang]}.html`)
                });
            map2markers.push(marker);
            marker.addTo(map2);
        }
    }

    function getPredicateOption(predicate, language) {
        let option = document.createElement('option');
        option.value = predicate;
        if (language === 'ru') {
            const predicateRu = predicateEn2Ru[predicate];
            option.innerHTML = predicateRu
                .replace(/_/g, ' ')
                .replace(/#(.*)#/g, ' ($1)') + ` [<em>${predicate2schemaRu[predicateRu]}</em>]`;
        } else {
            option.innerHTML = predicate
                .replace(/_/g, ' ')
                .replace(/#(.*)#/g, ' ($1)') + ` [<em>${predicate2schema[predicate]}</em>]`;
        }
        return option;
    }

    function removeNonFirstChildren(element) {
        let children = element.children;
        for (let i = children.length-1; i > 0; i--)
            element.removeChild(children[i]);
    }

    function populateSelectMenus() {
        const language = nextSelectLang;
        nextSelectLang = nextSelectLang === 'en' ? 'ru' : 'en';
        // Populate select menus
        let sortedPredicates = [];
        for (const key in predicateLanguageLocusDict)
            if (predicateLanguageLocusDict.hasOwnProperty(key))
                sortedPredicates.push(key);
        if (language === 'ru')
            sortedPredicates.sort((pred1, pred2) => {
                const pred1Ru = predicateEn2Ru[pred1],
                    pred2Ru = predicateEn2Ru[pred2];
                if (pred1Ru < pred2Ru)
                    return -1;
                else if (pred1Ru > pred2Ru)
                    return 1;
                else
                    return 0;
            });
        else
            sortedPredicates.sort();
        removeNonFirstChildren(document.getElementById('tr-locus-select'));
        removeNonFirstChildren(document.getElementById('predicate1-select'));
        removeNonFirstChildren(document.getElementById('predicate2-select'));
        for (const key of sortedPredicates) {
                document.getElementById('tr-locus-select').appendChild(getPredicateOption(key, language));
                document.getElementById('predicate1-select').appendChild(getPredicateOption(key, language));
                document.getElementById('predicate2-select').appendChild(getPredicateOption(key, language));
            }
        document.getElementById('tr-locus-select').value   = '---';
        document.getElementById('predicate1-select').value = '---';
        document.getElementById('predicate2-select').value = '---';

        // Rename the button
        let buttons = document.getElementsByClassName('language-switch-button');
        for (let i = 0; i < buttons.length; i++) {
            if (language === 'ru')
                buttons[i].value = buttons[i].value.replace('Russian', 'English');
            else
                buttons[i].value = buttons[i].value.replace('English', 'Russian');
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        populateSelectMenus('en');

        map1 = L.map('transitivity-map', {zoomControl: false});
        map1.setView([52.483333, 96.085833], 2);
        L.control.zoom({position: 'bottomleft'}).addTo(map1);
        L.tileLayer(
            'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
            {
                attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>',
                maxZoom: 18,
            })
            .addTo(map1);

        map2 = L.map('predicate-pair-map', {zoomControl: false});
        map2.setView([52.483333, 96.085833], 2);
        L.control.zoom({position: 'bottomleft'}).addTo(map2);
        L.tileLayer(
            'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
            {
                attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>',
                maxZoom: 18,
            })
            .addTo(map2);
    });
</script>